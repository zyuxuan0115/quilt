Overall Approach: Two-Phase Optimization

Because finding the absolute best way to partition the graph involves
simultaneously choosing the number of subgraphs, their roots, and assigning all
other nodes (which is extremely complex), we break the problem into two related
phases:

Phase 1: Root Selection (The Heuristic Guessing Game)

Goal: To propose promising candidate sets of nodes R = {r_1, r_2, ..., r_k} that
will serve as the roots for the k subgraphs.

Why it's hard: We don't know the best number k beforehand, and any node could
potentially be a root. Trying all possibilities is computationally infeasible
for non-trivial graphs.

Our Strategy (Simple Heuristic):

We always include the original graph's root node (r_G) in any candidate set R,
because it has to belong somewhere, and making it a root is a natural choice.

We start by testing the simplest case: k=1, where R = {r_G}.

Then, we iteratively try larger sets R. For k=2, we try {r_G, node_A}, {r_G,
node_B}, etc., for all other nodes A, B, .... For k=3, we try {r_G, node_A,
node_B}, etc.

We limit how high k can go (using max_k) to keep the search practical.

For each candidate set R generated, we proceed to Phase 2 to see how good that
choice of roots actually is.

Output of Phase 1: The best set of roots R found across all tested k values,
based on the results from Phase 2.

Phase 2: Subgraph Construction (The Precise Assignment via ILP)

Goal: Given a specific set of candidate roots R = {r_1, ..., r_k} proposed by
Phase 1, determine the exact assignment of all graph nodes to these k potential
subgraphs (G_1, ..., G_k) such that all rules are followed and the cross-edge
cost is minimized for this specific R.

Tool: We formulate this assignment problem as an Integer Linear Program (ILP).
An ILP is a mathematical optimization model that uses:

Decision Variables: Representing the choices we need to make (here, which nodes
go into which subgraph).

Objective Function: A mathematical formula representing the quantity we want to
minimize (here, the total weight of crossing edges).

Constraints: Mathematical inequalities or equalities representing the rules that
must be obeyed.

We then use a specialized ILP solver (like Gurobi) to find the optimal yes/no
decisions for the variables that satisfy all constraints and give the best
objective value.

Output of Phase 2: For the given R, either:

The minimum possible cross-edge cost and the corresponding node assignments.

A declaration that it's impossible to satisfy the rules with this R
(infeasible).

The Integer Linear Program (ILP) Formulation (Phase 2)

Given a fixed set of potential roots R = {r_1, ..., r_k}:

Decision Variables:

We create a binary (0 or 1) variable y[i, r] for each node i and each root r in
R, provided that node i is reachable from root r in the original graph.

y[i, r] = 1 means: "Yes, assign node i to the sub-network G_r whose designated
root is r."

y[i, r] = 0 means: "No, do not assign node i to the sub-network G_r." (Note: A
node i can be assigned to multiple sub-networks if needed).

Objective Function (Minimize Total Weight of Cross-Edges):

Minimize: (Sum of weights w_ij for all edges (i,j) where j is in R)
- (Sum of (w_ij * y[i, j]) for all edges (i,j) where j is in R and y[i,j]
  exists)

Explanation:

The first part calculates the maximum potential cost, assuming every edge
pointing to a chosen root j is a cross-edge.

The second part calculates the "savings". If an edge (i, j) points to a root j,
and we decide to include i in the subgraph G_j (making y[i, j] = 1), then that
edge is internalized and its weight w_ij is subtracted from the potential cost.

Minimizing this difference forces the solver to internalize high-weight edges
pointing to roots whenever possible (respecting other constraints), leaving only
the unavoidable or lower-weight cross-edges contributing to the final minimized
cost.

Constraints (The Rules in Math Form):

Constraint 1: Root Inclusion: Every chosen root r must belong to its own
subgraph.

y[r, r] = 1 for all r in R.

Constraint 2: Node Coverage: Every node i in the entire graph must be assigned
to at least one subgraph.

Sum(y[i, r] for all r in R such that y[i,r] exists) >= 1 for every node i.

Constraint 3: Memory Capacity (M): For each subgraph G_r, the sum of memory
requirements m_i for all nodes i assigned to it must not exceed M.

Sum(m_i * y[i, r] for all i such that y[i,r] exists) <= M for each root r in R.

Constraint 4: Compute Capacity (C): Similar to memory, the total compute c_i for
nodes assigned to G_r must not exceed C.

Sum(c_i * y[i, r] for all i such that y[i,r] exists) <= C for each root r in R.

Constraint 5: Connectivity: If a node i (that is not the root r) is in subgraph
G_r, it must have at least one parent j that is also in G_r.

y[i, r] <= Sum(y[j, r] for all predecessors j of i such that y[j,r] exists) for
each r in R and each node i != r.

Constraint 6: Cross-Edge Structure Rule: If an edge (i, j) exists, and the
target node j is not one of the chosen roots in R, then i and j must be treated
as a unit for any given subgraph G_r. If i is included in G_r, j must also be
included.

y[i, r] <= y[j, r] for every edge (i, j) where j is NOT in R, and for every root
r in R (where variables exist).

This ILP formulation, when solved for a specific R, finds the best way to assign
nodes to satisfy all capacity, connectivity, coverage, and structural rules
while minimizing the cost of edges crossing between the subgraphs rooted at R.
  
The two-phase approach uses this ILP repeatedly to evaluate different choices
of R.
